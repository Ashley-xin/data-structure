### java学习之练习题（day4选择题）

```java
1.以下代码运行输出的是( C )
public class Person{
	private String name = "Person";
	int age=0;
}
public class Child extends Person{
	public String grade;
	public static void main(String[] args){
		Person p = new Child();
		System.out.println(p.name);
	}
}

A 输出：Person
B 没有输出
C 编译出错
D 运行出错

**解析**
子类无法继承父类中的私有成员，但是子类对象的内存里是有父类成员的，但不代表可以用！！
name成员在父类Person中是私有属性的，不可以在子类中直接调用！！

Java中四种访问权限总结：
1、private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。
	被其修饰的属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。

2、default：即不加任何访问修饰符，通常称为“默认访问权限“或者“包访问权限”。
	该模式下，只允许在同一个包中进行访问。

3、protected: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护访问权限”。
	被其修饰的属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。

4、public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。
	被其修饰的类、属性以及方法不仅可以跨类访问，而且 允许跨包访问。

```

```java
2.以下程序的输出结果为( D )
class Base{
	public Base(String s){
		System.out.print("B");
	}
}
public class Derived extends Base{
	public Derived (String s) {
		System.out.print("D");
	}
	public static void main(String[] args){
		new Derived("C");
	}
}

A BD
B DB
C C
D 编译错误

**解析**
在调用子类构造器之前，会先调用父类构造器，当子类构造器中没有使用"super(参数或无参数)"指定调用父类构造器时，是默认调用父类的无参构造器，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。
```

```java
3.下面关于构造方法的说法不正确的是 ( B )
A 构造方法也属于类的方法，可以创建对象的时候给成员变量赋值
B 构造方法不可以重载
C 构造方法没有返回值
D 构造方法一定要和类名相同

**解析**
构造方法是一种特殊的方法，它是一个与类同名的方法。对象的创建就是通过构造方法来完成，其功能主要是完成对象的初始化。当类实例化一个对象时会自动调用构造方法。构造方法和其他方法一样也可以重载。

构造方法是一种特殊的成员方法,它的特殊性反映在如下几个方面:
1.构造方法作用：（1）.构造出来一个类的实例 （2）.对构造出来个一个类的实例（对象）初始化。
2.构造方法的名字必须与定义他的类名完全相同，没有返回类型，甚至连void也没有。
3.主要完成对象的初始化工作，构造方法的调用是在创建一个对象时使用new操作进行的。
4.类中必定有构造方法，若不写，系统自动添加无参构造方法。接口不允许被实例化，所以接口中没有构造方法。
5.不能被static、final、synchronized、abstract和native修饰。
6.构造方法在初始化对象时自动执行,一般不能显式地直接调用.当同一个类存在多个构造方法时，java编译系统会自动按照初始化时最后面括号的参数个数以及参数类型来自动一一对应。完成构造函数的调用。
7.构造方法分为两种：无参构造方法 有参构造方法
构造方法可以被重载。没有参数的构造方法称为默认构造方法，与一般的方法一样，构造方法可以进行任何活动，但是经常将他设计为进行各种初始化活动，比如初始化对象的属性。
8.构造代码块：
　　(1)作用：给对象进行初始化，对象一建立就执行，而且优先于构造函数执行
　　(2)构造代码块和构造函数的区别：
　　构造代码块是给所有不同对象的共性进行统一初始化，构造函数是给对应的对象进行初始化
9.子类继承父类中，
　　***子类的实例化过程
　　***构造方法不能被子类继承
　　***子类创建对象时，会先去创建父类的对象。
　　默认是去调用父类的无参构造方法。
　　***子类构造方法中，第一行默认是super()
　　***为什么子类中第一行会默认有super()
　　因为他继承父类的成员使用，使用前这些成员必须初始化，
　　而他们是父类的成员，所以，必须通过父类进行初始化。
　　所以，会先创建一个父类的对象。
　　**当父类没有无参构造方法时
必须使用this或者super调用其他的构造方法。
10.自定义类中，如果不写构造方法，java系统会默认添加一个无参的构造方法。如果写了一个有参的构造方法，就一定要写无参构造方法。
　　如果想使用无参的构造方法，就必须手动给出无参构造方法。
　　建议：一般情况下，我们自定义的类都要手动给出无参构造方法。。
```

```java
4.在异常处理中，以下描述不正确的有( D )
A try块不可以省略
B 可以使用多重catch块
C finally块可以省略
D catch块和finally块可以同时省略
    
**解析**
1、try~用于监听。
	将要被监听的代码(可能抛出异常的代码)放在try语句块之内，
	当try语句块内发生异常时，异常就被抛出。

2、catch~用于捕获异常。catch用来捕获try语句块中发生的异常。

3、 finally~finally修饰的语句块总是会被执行。
	它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。
	只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，
	如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。

4、throw~用于抛出异常。

5、throws~用在方法签名中，用于声明该方法可能抛出的异常。

```

```java
5.下列描述中，错误的是( C )
A SQL语言又称为结构化查询语言
B java中”static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访
问
C 面向对象开发中，引用传递意味着传递的并不是实际的对象，而是对象的引用，因此，外部对引用对
象所做的改变不会反映到所引用的对象上
D java是强类型语言，javascript是弱类型语言
E 面向对象的三大特性包括：封装，继承，多态

**解析**
对象被值传递和引用传递的区别？

1、对象被值传递，意味着传递了对象的一个副本。
	因此，就算是改变了对象副本，也不会影响源对象的值。
2、对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。
	因此，外部对引用对象所做的改变会反映到所有的对象上。

```

```java
6.下列哪种说法是正确的？( C )
A 实例方法可直接调用超类的实例方法
B 实例方法可直接调用超类的类方法
C 实例方法可直接调用本类的类方法
D 实例方法可直接调用其他类的实例方法
    
**解析**
//超类方法可能为私有
类方法就是静态方法。其它的就是实例方法

实例方法可以对当前对象的实例变量进行操作，也可以对类变量进行操作，但类方法不能访问实例变量。实例方法必须由实例对象来调用，而类方法除了可由实例对象调用外，还可以由类名直接调用。

另外，在类方法中不能使用 this 或 super。 关于类方法的使用，有如下一些限制：

1 在类方法中不能引用对象变量。

2 在类方法中不能使用super、this关键字。

3 类方法不能调用类中的对象方法。

与类方法相比，实例方法几乎没有什么限制：

1 实例方法可以引用对象变量（这是显然的），也可以引用类变量。

2 实例方法中可以使用super、this关键字。

3 实例方法中可以调用类方法。
```

```java
7.有以下代码片段：( D )
String str1="hello";
String str2="he"+ new String("llo");
System.out.println(str1==str2);
请问输出的结果是：
A true
B 都不对
C null
D false
    
 **解析**
 1）String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。
 
2）String类底层是char数组来保存字符串的。
 
对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象

    字符串常量池

    在class文件中有一部分来存储编译期间生成的字面常量以及符号引用，这部分叫做class文件常量池，在运行期间对应着方法区的运行时常量池。
 
    JVM为了减少字符串对象的重复创建，其维护了一个特殊的内存，这段内存被成为字符串常量池或者字符串字面量池
 
    工作原理
    
    当代码中出现字面量形式创建字符串对象时，JVM首先会对这个字面量进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回，否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用。
 
    实现前提
 
    字符串常量池实现的前提条件就是Java中String对象是不可变的，这样可以安全保证多个变量共享同一个对象。如果Java中的String对象可变的话，一个引用操作改变了对象的值，那么其他的变量也会受到影响，显然这样是不合理的。
 
 
 
    String str1 = "hello";
 
    这里的str1指的是方法区中的字符串常量池中的“hello”，编译时期就知道的；
 
    String str2 = "he" + new String("llo");
 
    这里的str2必须在运行时才知道str2是什么，所以它是指向的是堆里定义的字符串“hello”，所以这两个引用是不一样的。
 
    如果用str1.equal(str2)，那么返回的是true；因为String类重写了equals()方法。
 
    编译器没那么智能,它不知道"he" + new String("llo")的内容是什么,所以才不敢贸然把"hello"这个对象的引用赋给str2.
 
    如果语句改为:"he"+"llo"这样就是true了。
 
    new String("zz")实际上创建了2个String对象，就是使用“zz”通过双引号创建的（在字符串常量池），另一个是通过new创建的（在堆里）。只不过他们的创建的时期不同，一个是编译期，一个是运行期。
 
    String s = "a"+"b"+"c";
 
    语句中，“a”,"b", "c"都是常量，编译时就直接存储他们的字面值，而不是他们的引用，在编译时就直接将它们连接的结果提取出来变成"abc"了。
 
```

```java
8.程序读入用户输入的一个值，要求创建一个自定义的异常，如果输入值大于 10 ，使用 throw 语句显式地引
发异常，异常输出信息为 ”something’swrong!” ，语句为（ A ）
A if(i>10)throw new Exception("something’swrong!");
B if(i>10)throw Exception e("something’swrong!");
C if(i>10) throw new Exception e("something’swrong!");
D if(i>10)throw Exception( "something’swrong!");
    
**解析**
解析：
自定义异常中不需要写那个e
自定义的新异常名称不能与Java中定义的相同。应该另起别名
```

```java
9.以下关于集合类 ArrayList 、 LinkedList 、 HashMap 描述错误的是：( C )
A HashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值
B ArrayList和LinkedList均实现了List接口
C 添加和删除元素时，ArrayList的表现更佳
D ArrayList的访问速度比LinkedList快

**解析**
解析：
A、HashMap实现了Map接口的，它的Key和Value都可以是null，
	但是Hashtable中，Key和Value都不能是null。
B、ArrayList与LinkedList都实现了List接口，继承了AbstractList类。
C、ArrayList底层是动态数组是实现，随机位置添加和删除，
	都需要移动数组的数据，而LinkedList底层是双向链表，只需要修改Node节点的引用。
D、随机访问数组要比链表块。

```

```java
10.关于 Java 线程，下面说法错误的是（ C ）。
A 创建线程可以通过实现Runnable接口和继承Thread类
B java利用线程使整个系统成为异步
C 新线程一旦被创建，它将自动开始运行

**解析**
解析：
A 创建线程的三种方法：
	（1）继承Thread类；（2）实现Runnable接口；（3）实现Collable接口。
B 可以利用线程使系统异步处理，也可加synchronized关键字使同步。
C 新线程需要覆写run（）方法才能开始运行
```

